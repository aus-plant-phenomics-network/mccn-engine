{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>MCCN-Engine is a python library for loading and combining STAC described asset, generated using the stac_generator, into an xarray datacube.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install from PyPi:</p> <pre><code>pip install mccn-engine\n</code></pre>"},{"location":"#workflow","title":"Workflow","text":""},{"location":"#note","title":"Note","text":"<p>The current version of the mccn-engine only works with STAC items generated using the library stac_generator.</p>"},{"location":"#item-discovery","title":"Item Discovery","text":"<p>The first phase is discovering all described STAC assets. The engine does this by checking one of the following parameters: </p> <ul> <li><code>items</code>: a sequence of <code>pystac.Item</code> objects.</li> <li><code>collection</code>: a <code>pystac.Collection</code> object that contains items to be loaded.</li> <li><code>endpoint</code>: <ul> <li>a <code>str/Path</code> path to the file <code>collection.json</code> on local file system. This collection json will be parsed into a <code>pystac.Collection</code> object, from which all items will be collected. </li> <li>a <code>tuple[str, str]</code>, containing a STAC API endpoint url, and the collection id. A request will be made to the endpoint, from which all items will be collected. </li> </ul> </li> </ul>"},{"location":"#filtering-option","title":"Filtering Option","text":"<p>By default, the mccn engine will load all items found in the discovery phase. Users can filter items to be loaded into the data cube via the following options to be provided to the constructor: </p>"},{"location":"#filtering-by-geobox","title":"Filtering by geobox","text":"<p>For building datacubes, we utilise the GeoBox object, which is essentially a bounding box that knows its resolution and crs. The engine constructor accepts the following parameters: </p> <ul> <li><code>geobox</code>: if the user provides a <code>GeoBox</code> object, no other geobox related parameters will be parsed. Only assets that overlapp with the geobox (either contains, is contained by, or intersects with) will be loaded.</li> <li><code>shape</code>: cube shape - e.g <code>(100, 100)</code></li> <li><code>resolution</code>: cube spatial resolution - e.g 0.005.</li> <li><code>bbox</code>: cube bounding box.</li> <li><code>crs</code>: cube's CRS.</li> </ul> <p>If <code>geobox</code> value is not provided, user MUST provide one of <code>shape</code> or <code>resolution</code>. If no spatial filtering is needed, the user can just leave <code>bbox</code> to None.</p> <p>The easiest way to build a geobox is to just provide the <code>shape</code> value, from which a geobox of matching shape will be derived from the bounding box that contains all assets. </p>"},{"location":"#filtering-by-dates","title":"Filtering by dates:","text":"<p>User can provide a date string, a None value, or a python <code>datetime.datetime</code> or <code>pandas.Timestamp</code> object. If <code>start_ts</code> is None, there is no time lowerbound filtering applied and vice-versa. If timestamp is not utc, value will be converted to utc. If timestamp is not timezone aware, will be treated as utc time. </p> <ul> <li><code>start_ts</code>: starting timestamp, inclusive. </li> <li><code>end_ts</code>: ending timestamp, inclusive.</li> </ul>"},{"location":"#filtering-by-bands","title":"Filtering by bands:","text":"<p>User can provide a set of band names to be loaded as layers in the cube. Only assets containing the matched bands will be loaded. Note that by default, the engine load all geometry layers of vector assets, regardless of whether the vector assets contain the requesting bands. Users can change this behaviour by setting <code>use_all_vectors</code> to False. </p>"},{"location":"#rasterising-options","title":"Rasterising Options","text":"<p>User can provide the following parameters to control how data get written to the datacube: </p> <ul> <li><code>time_groupby</code>: group similar dates into a single value and aggregate data values within the period into the same layer. For instance, if <code>time_groupby</code> is <code>year</code>, a time series values over the same year (365 days) will be aggregated into a single layer with date being the 1st day of that year. Acceptable values for <code>time_groupby</code> are:<ul> <li><code>year</code>: values within the same year are groupped together</li> <li><code>month</code>: values within the same month are groupped together</li> <li><code>day</code>: values within the same hour are groupped together</li> <li><code>minute</code>: values within the same minute are groupped together</li> <li><code>time</code>: does not perform grouping. </li> </ul> </li> <li><code>nodata</code>: fill value for nodata. If a single value is provided, the value will be used for all layers. If a dictionary is provided, each nodata value will apply for matching key layers. Defaults to 0.</li> <li><code>nodata_fallback</code>: fill value fall back for nodata. If a dictionary is provided for nodata, the nodata_fallback value will be used for layers that are not in the nodata dict. Defaults to 0.</li> <li><code>time_groupby</code>: how datetimes are groupped. Acceptable values are year, month, day, hour, minute or time. If time is provided, no time round up is performed. If time is a value, will round up to the nearest matching date. Defaults to \"time\".</li> <li><code>merge_method</code>: how overlapping values are merged. Acceptable values are min, max, mean, sum, and replace and None. If None is provided, will use the replace strategy. Also accepts a dictionary if fine-grain control over a specific layer is required. Defaults to None.</li> <li><code>merge_method_fallback</code>: merge value fallback, applies when a layer name is not in merge_method dictionary. Defaults to \"replace\".</li> <li><code>dtype</code>: set dtype for a layer. Also accepts a dictionary for fine-grained control. Defaults to None.</li> <li><code>dtype_fallback</code>: dtype fallback, when a layer's name is not in dtype dictionary. Defaults to \"float64\"</li> </ul>"},{"location":"api_reference/","title":"Reference","text":""},{"location":"api_reference/#mccn.client.MCCN","title":"<code>MCCN</code>","text":""},{"location":"api_reference/#mccn.client.MCCN.__init__","title":"<code>__init__(endpoint=None, collection=None, items=None, shape=None, resolution=None, bbox=None, anchor='default', crs=4326, geobox=None, start_ts=None, end_ts=None, bands=None, mask_only=False, use_all_vectors=True, x_dim='x', y_dim='y', t_dim='time', mask_name='__MASK__', combine_mask=False, rename_bands=None, process_bands=None, nodata=0, nodata_fallback=0, time_groupby='time', merge_method=None, merge_method_fallback='replace', dtype=None, dtype_fallback='float64', num_workers=4)</code>","text":"<p>Constructor for the mccn engine</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str | Path | tuple[str, str] | None</code> <p>discover project by endpoint. Endpoint can be a tuple of string, which specifies the STAC API URL, and stac collection ID. Endpoint can also be a string or a Path object to a <code>collection.json</code> file on local file system. Defaults to None.</p> <code>None</code> <code>collection</code> <code>pystac.Collection | None</code> <p>discover project by a pystac Collection object. Defaults to None.</p> <code>None</code> <code>items</code> <code>Sequence[pystac.Item] | None</code> <p>discover project by a sequence of pystac Items. Defaults to None.</p> <code>None</code> <code>shape</code> <code>Shape_T | None</code> <p>define the shape of geobox. Defaults to None.</p> <code>None</code> <code>resolution</code> <code>Resolution_T | None</code> <p>define the resolution of the geobox. Defaults to None.</p> <code>None</code> <code>bbox</code> <code>BBox_T | None</code> <p>define the bounding box of the geobox. Defaults to None.</p> <code>None</code> <code>anchor</code> <code>AnchorPos_T</code> <p>additional geobox parameter. Defaults to \"default\".</p> <code>'default'</code> <code>crs</code> <code>CRS_T</code> <p>geobox's crs. Defaults to 4326.</p> <code>4326</code> <code>geobox</code> <code>GeoBox | None</code> <p>geobox object. Defaults to None.</p> <code>None</code> <code>start_ts</code> <code>str | pd.Timestamp | datetime.datetime | None</code> <p>date filtering - start. Defaults to None.</p> <code>None</code> <code>end_ts</code> <code>str | pd.Timestamp | datetime.datetime | None</code> <p>date filtering - end. Defaults to None.</p> <code>None</code> <code>bands</code> <code>set[str] | None</code> <p>set of requested bands. Defaults to None.</p> <code>None</code> <code>mask_only</code> <code>bool</code> <p>whether to load only masks for vector assets. Defaults to False.</p> <code>False</code> <code>use_all_vectors</code> <code>bool</code> <p>when bands are requested, should all vectors be loaded or only vectors with matching bands be loaded. Non-matching vectors will have their geometry layers loaded to the datacube if True. Defaults to True.</p> <code>True</code> <code>x_dim</code> <code>str</code> <p>x dimension name of the datacube. Defaults to \"x\".</p> <code>'x'</code> <code>y_dim</code> <code>str</code> <p>y dimension name of the datacube. Defaults to \"y\".</p> <code>'y'</code> <code>t_dim</code> <code>str</code> <p>t dimension name of the datacube. Defaults to \"time\".</p> <code>'time'</code> <code>mask_name</code> <code>str</code> <p>name of the combined mask layer, if combine_mask is True. Defaults to \"MASK\".</p> <code>'__MASK__'</code> <code>combine_mask</code> <code>bool</code> <p>whether to combine all geometry layers of all vector assets into a single layer. By default, each geometry layer will be loaded as an independent geometry layer. Defaults to False.</p> <code>False</code> <code>nodata</code> <code>Nodata_Map_T</code> <p>fill value for nodata. If a single value is provided, the value will be used for all layers. If a dictionary is provided, each nodata value will apply for matching key layers. Defaults to 0.</p> <code>0</code> <code>nodata_fallback</code> <code>Nodata_T</code> <p>fill value fall back for nodata. If a dictionary is provided for nodata, the nodata_fallback value will be used for layers that are not in the nodata dict. Defaults to 0.</p> <code>0</code> <code>time_groupby</code> <code>TimeGroupby</code> <p>how datetimes are groupped. Acceptable values are year, month, day, hour, minute or time. If time is provided, no time round up is performed. If time is a value, will round up to the nearest matching date. Defaults to \"time\".</p> <code>'time'</code> <code>merge_method</code> <code>MergeMethod_Map_T</code> <p>how overlapping values are merged. Acceptable values are min, max, mean, sum, and replace and None. If None is provided, will use the replace strategy. Also accepts a dictionary if fine-grain control over a specific layer is required. Defaults to None.</p> <code>None</code> <code>merge_method_fallback</code> <code>MergeMethod_T</code> <p>merge value fallback, applies when a layer name is not in merge_method dictionary. Defaults to \"replace\".</p> <code>'replace'</code> <code>dtype</code> <code>DType_Map_T</code> <p>set dtype for a layer. Also accepts a dictionary for fine-grained control. Defaults to None.</p> <code>None</code> <code>dtype_fallback</code> <code>Dtype_T</code> <p>dtype fallback, when a layer's name is not in dtype dictionary. Defaults to \"float64\".</p> <code>'float64'</code>"},{"location":"api_reference/#mccn.client.MCCN.get_collection","title":"<code>get_collection(endpoint, collection=None)</code>  <code>staticmethod</code>","text":"<p>Try to load collection from endpoint.</p> <p>Raises <code>EndpointType</code> if endpoint is not an acceptable type, or <code>EndpointException</code> if endpoint is not reachable</p>"},{"location":"filter/","title":"Filter","text":""},{"location":"filter/#querying-items-over-a-date-time-period","title":"Querying items over a date time period","text":""},{"location":"filter/#querying-items-over-a-bounding-box","title":"Querying items over a bounding box","text":""},{"location":"filter/#querying-items-that-have-specific-bands","title":"Querying items that have specific bands","text":""}]}